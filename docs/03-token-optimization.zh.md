# Claude Code 的令牌优化

> **语言 (Language)**: [English](03-token-optimization.md) | 简体中文

在大型代码库中使用 Claude Code 时,最大化效率并降低成本的策略。

## 目录

- [理解令牌使用](#理解令牌使用)
- [上下文窗口管理](#上下文窗口管理)
- [高效提示](#高效提示)
- [大型代码库策略](#大型代码库策略)
- [缓存和重用](#缓存和重用)
- [测量和监控](#测量和监控)
- [成本优化](#成本优化)

---

## 理解令牌使用

### 什么是令牌?

令牌是 Claude 处理的文本基本单位:

```
"Hello, world!" ≈ 4 个令牌
"function getUserById(id) { }" ≈ 9 个令牌
```

**近似转换:**

- 1 令牌 ≈ 0.75 个单词(英文)
- 1 令牌 ≈ 4 个字符
- 100 令牌 ≈ 75 个单词 ≈ 1-2 行代码

### 令牌成本

**输入令牌**(你发送给 Claude 的内容):

- 读取文件
- 你的提示
- 对话历史
- CLAUDE.md 上下文

**输出令牌**(Claude 生成的内容):

- Claude 编写的代码
- 解释说明
- 响应

**成本比率:**

- 输出令牌的成本通常是输入令牌的 3-5 倍
- 将优化重点放在减少不必要的输入上

### 令牌消耗的位置

**高令牌使用:**

```
❌ "请读取 src/ 中的所有文件并重构它们"
   → 读取 50 个文件 × 500 令牌 = 25,000 令牌

❌ "重写这个 1000 行的文件"
   → 输入: 1,000 行 × 10 令牌 = 10,000 令牌
   → 输出: 1,000 行 × 10 令牌 = 10,000 令牌
   → 总计: 20,000 令牌(输出成本更高!)
```

**低令牌使用:**

```
✅ "在 src/auth.js 第 45 行,将 validateUser 改为 validateEmail"
   → 输入: 特定文件 + 行号 + 指令 = ~100 令牌
   → 输出: 仅修改的行 = ~20 令牌
   → 总计: 120 令牌
```

**令牌使用公式:**

```
总令牌 = 上下文 + 提示 + 历史 + 输出
其中:
- 上下文 = CLAUDE.md + 其他配置文件
- 提示 = 你的请求
- 历史 = 之前的对话消息
- 输出 = Claude 的响应
```

---

## 上下文窗口管理

### 200K 令牌窗口

Claude Code 有 200,000 令牌的上下文窗口:

```
┌─────────────────────────────────────┐
│ 总计: 200,000 令牌                   │
├─────────────────────────────────────┤
│ CLAUDE.md: ~5,000 令牌               │
│ 对话历史: ~20,000                    │
│ 当前请求: ~10,000                    │
│ 可用于响应: ~165,000                 │
└─────────────────────────────────────┘
```

### 自动摘要

在 `.claude/settings.json` 中配置:

```json
{
  "context": {
    "maxTokens": 100000,
    "summarizeOldMessages": true,
    "summarizeThreshold": 50000
  }
}
```

**工作原理:**

```
1. 对话达到 50,000 令牌
2. 最旧的消息自动摘要
3. 摘要替换完整消息
4. 上下文窗口保持在限制内
5. 最近的消息保持完整详细
```

**摘要示例:**

```
之前 (5,000 令牌):
用户: "创建一个带 JWT 的用户认证系统..."
助手: "我将创建一个综合的认证系统...
[包含代码的完整 4,000 令牌响应]"

之后 (500 令牌):
摘要: "在 src/auth/ 创建了基于 JWT 的认证系统,
包含登录、登出和令牌刷新端点"
```

### 增量编辑 vs. 完全重写

**❌ 低效 - 完全文件重写:**

```
用户: "为 getUserById 添加错误处理"

Claude 读取整个 500 行文件 (5,000 令牌)
Claude 重写整个文件 (5,000 令牌输出)
总计: 10,000 令牌
```

**✅ 高效 - 增量编辑:**

```
用户: "在 src/users.js 第 45 行,为 getUserById 中的
数据库查询添加 try-catch"

Claude 只读取特定函数 (100 令牌)
Claude 只输出修改部分 (50 令牌)
总计: 150 令牌
```

**最佳实践:**

```javascript
// 不要说: "用更好的错误处理重写这个文件"
// 而是说: "在第 45 行为 getUserById 函数添加 try-catch"

// Claude 使用 Edit 工具:
Edit(
  file: "src/users.js",
  old_string: "const user = await db.query('SELECT...')",
  new_string: "try {\n  const user = await db.query('SELECT...')\n} catch (error) {\n  logger.error('Database error', error);\n  throw error;\n}"
)

// 使用的令牌: ~100 (vs 完全重写的 10,000)
```

### 选择性文件读取

**❌ 读取整个目录:**

```
用户: "审查 src/ 中的所有代码"

Claude 读取:
- src/users.js (5,000 令牌)
- src/posts.js (3,000 令牌)
- src/comments.js (4,000 令牌)
- src/auth.js (6,000 令牌)
总计: 18,000 令牌(甚至还没开始审查!)
```

**✅ 针对性读取:**

```
用户: "审查 src/auth.js 中的认证逻辑,
特别是 validateToken 函数"

Claude 读取:
- src/auth.js (6,000 令牌)
- 专注于 validateToken 函数
总计: 6,000 令牌(减少 67%)
```

**先使用 Grep:**

```
用户: "查找所有使用已弃用 oldApi 函数的文件,
然后显示第一个出现的位置"

1. Claude 运行 grep (50 令牌)
2. 找到 5 个文件
3. 只读取第一个文件 (1,000 令牌)
总计: 1,050 令牌

vs. 读取所有 5 个文件 = 5,000+ 令牌
```

---

## 高效提示

### 具体而非冗长

**❌ 冗长 (500 令牌):**

```
我想请你帮我创建一个可以处理用户认证的函数。这个函数应该能够
接受用户名和密码,然后通过查询数据库来检查这些凭证是否有效。
如果有效,它应该返回成功消息,但如果无效,它应该返回错误消息。
另外,请确保处理数据库查询期间可能发生的任何潜在错误,并使用
async/await 语法,因为我们在整个项目中都在使用它。哦,如果你
还能添加一些注释来解释代码在做什么,那就太好了。
```

**✅ 简洁 (50 令牌):**

```
创建一个 async validateUser(username, password) 函数:
1. 查询数据库获取凭证
2. 如果有效返回 true,否则返回 false
3. 处理数据库错误
4. 使用 async/await
```

**令牌节省: 90%**

### 使用引用而非重复

**❌ 重复的:**

```
用户: "在 src/users.js 中,getUserById 函数..."
[Claude 响应]

用户: "现在在 src/users.js 中,getUserById 函数,添加验证..."
[每次都重复上下文]
```

**✅ 使用引用:**

```
用户: "在 src/users.js 中,getUserById 函数..."
[Claude 响应]

用户: "在同一个函数中,添加验证..."
[Claude 知道上下文]
```

### 利用 CLAUDE.md 上下文

**❌ 重复标准:**

```
用户: "创建一个用户模型。使用 camelCase 命名变量,
PascalCase 命名类,添加 JSDoc 注释,使用 try-catch
处理错误,并使用 Jest 先写测试..."
[每次请求都重复标准 = 每次请求 200+ 令牌]
```

**✅ 引用 CLAUDE.md:**

```
用户: "按照我们的标准创建用户模型"
[Claude 读取 CLAUDE.md 一次 = 5,000 令牌]
[后续请求 = 10 令牌: "按照我们的标准"]
```

**一次性上下文加载:**

```
加载 CLAUDE.md: 5,000 令牌(一次)
100 次请求 × 10 令牌 = 1,000 令牌

vs.

100 次请求 × 200 令牌 = 20,000 令牌
节省: 14,000 令牌(减少 70%)
```

### 批量相关操作

**❌ 顺序的单独请求:**

```
用户: "为 Post 模型添加 userId 字段"
[Claude 读取 Post 模型: 1,000 令牌]

用户: "为 Post 模型添加 createdAt 字段"
[Claude 再次读取 Post 模型: 1,000 令牌]

用户: "为 Post 模型添加 updatedAt 字段"
[Claude 再次读取 Post 模型: 1,000 令牌]

总计: 仅文件读取就 3,000 令牌
```

**✅ 批量请求:**

```
用户: "为 Post 模型添加这些字段: userId, createdAt, updatedAt"
[Claude 读取 Post 模型一次: 1,000 令牌]

总计: 1,000 令牌(减少 67%)
```

---

## 大型代码库策略

### 模块化架构

**按功能组织:**

```
src/
├── users/
│   ├── users.controller.js
│   ├── users.service.js
│   ├── users.model.js
│   └── users.test.js
├── posts/
│   ├── posts.controller.js
│   ├── posts.service.js
│   ├── posts.model.js
│   └── posts.test.js
```

**令牌使用的好处:**

- 一次处理一个功能
- 相关文件组织在一起
- 更小、更专注的上下文
- 减少交叉引用需求

**示例:**

```
❌ "审查整个应用程序"
   → 读取所有文件: 100,000+ 令牌

✅ "审查用户功能"
   → 只读取 users/ 目录: 5,000 令牌
```

### Agent 专业化

**使用多个专业化 Agent:**

```
┌─────────────────────────────────────┐
│ 主 Agent                            │
│ - 协调                              │
│ - 高层决策                          │
│ - 委托给专家                        │
└─────────────────────────────────────┘
         │
         ├──> 安全 Agent (专注于认证代码)
         ├──> 性能 Agent (专注于查询)
         └──> 测试 Agent (专注于测试文件)
```

**令牌效率:**

```
单个 agent 审查整个代码库:
- 加载所有文件: 50,000 令牌
- 审查所有内容: 20,000 令牌输出
- 总计: 70,000 令牌

三个专业化 agent:
- 每个加载相关文件: 3 × 5,000 = 15,000 令牌
- 每个审查其领域: 3 × 2,000 = 6,000 令牌
- 总计: 21,000 令牌(减少 70%)
```

### 摘要文件

**创建模块摘要:**

```javascript
// src/users/README.md
/**
 * 用户模块
 *
 * 处理用户管理,包括:
 * - 注册 (users.controller.js:createUser)
 * - 认证 (users.service.js:validateCredentials)
 * - 资料更新 (users.controller.js:updateUser)
 *
 * 数据库: users 表 (users.model.js)
 * 测试: users.test.js (95% 覆盖率)
 */
```

**使用:**

```
❌ "用户注册如何工作?"
   → 读取整个用户模块: 10,000 令牌

✅ "读取 users/README.md 然后解释注册"
   → 读取摘要 (200 令牌) + 特定函数 (500 令牌)
   → 总计: 700 令牌(减少 93%)
```

### 懒加载模式

**只在需要时加载文件:**

```
用户: "审查应用程序架构"

Claude:
1. 读取目录结构 (100 令牌)
2. 读取 README.md (500 令牌)
3. 读取 package.json (200 令牌)
目前总计: 800 令牌

用户: "现在看看认证实现"

Claude:
4. 读取 src/auth/ 文件 (5,000 令牌)
总计: 5,800 令牌

vs. 预先读取所有内容: 50,000 令牌
```

---

## 缓存和重用

### 会话持久性

**跨会话重用上下文:**

```
会话 1:
- 加载 CLAUDE.md: 5,000 令牌
- 处理用户功能: 10,000 令牌
- 总计: 15,000 令牌

会话 2(同一项目):
- 从会话 1 缓存 CLAUDE.md: 0 令牌
- 处理帖子功能: 10,000 令牌
- 总计: 10,000 令牌(节省 33%)
```

**启用缓存:**

```json
{
  "context": {
    "cacheEnabled": true,
    "cacheExpiry": 86400 // 24 小时
  }
}
```

### 模板重用

**创建可重用提示:**

```javascript
// .claude/templates/create-endpoint.md
创建一个新的 {METHOD} {ENDPOINT} 端点:

1. 将路由添加到 {ROUTER_FILE}
2. 在 {CONTROLLER_FILE} 中创建控制器函数
3. 为 {FIELDS} 添加验证
4. 在 {TEST_FILE} 中编写测试
5. 更新 API 文档

遵循 CLAUDE.md 中的 TDD 工作流程。
```

**使用:**

```
❌ 每次编写完整指令: 200 令牌 × 10 端点 = 2,000 令牌

✅ 使用模板: 50 令牌 × 10 端点 = 500 令牌
```

### 代码生成模板

**使用代码片段处理常见模式:**

```
用户: "使用模板为 Product 模型创建 CRUD 端点"

Claude:
1. 读取模板 (100 令牌)
2. 生成所有 5 个端点 (500 令牌输出)
总计: 600 令牌

vs. 单独解释每个端点: 2,000+ 令牌
```

---

## 测量和监控

### 跟踪令牌使用

**添加到 .claude/settings.json:**

```json
{
  "monitoring": {
    "logTokenUsage": true,
    "logFile": ".claude/token-usage.log"
  }
}
```

**日志格式:**

```json
{
  "timestamp": "2026-01-07T01:00:00Z",
  "request": "创建用户端点",
  "inputTokens": 1500,
  "outputTokens": 800,
  "totalTokens": 2300,
  "cost": 0.0023
}
```

### 分析使用模式

**查找高使用操作:**

```bash
# 前 10 个最昂贵的请求
cat .claude/token-usage.log | jq -s 'sort_by(.totalTokens) | reverse | .[0:10]'

# 每种请求类型的平均令牌
cat .claude/token-usage.log | jq -s 'group_by(.request) | map({request: .[0].request, avg: (map(.totalTokens) | add / length)})'

# 每日令牌使用
cat .claude/token-usage.log | jq -s 'group_by(.timestamp | split("T")[0]) | map({date: .[0].timestamp | split("T")[0], total: (map(.totalTokens) | add)})'
```

### 设置预算

**每会话限制:**

```json
{
  "budget": {
    "maxTokensPerSession": 50000,
    "maxTokensPerRequest": 10000,
    "alertThreshold": 40000
  }
}
```

**接近限制时发出警报:**

```
⚠️  令牌使用警报
─────────────────────────────
当前会话: 42,000 / 50,000 令牌 (84%)
接近限制。考虑:
- 开始新会话
- 使用更有针对性的请求
- 清除对话历史
```

---

## 成本优化

### 成本计算

**定价(示例):**

```
输入令牌:  $3 / 百万令牌
输出令牌: $15 / 百万令牌
```

**示例请求:**

```
输入: 10,000 令牌 × $3/M = $0.03
输出: 2,000 令牌 × $15/M = $0.03
总计: 每次请求 $0.06
```

**每月使用:**

```
100 次请求/天 × 30 天 = 3,000 次请求
3,000 × $0.06 = $180/月
```

### 优化策略

**1. 减少输出生成:**

```
❌ "重写这个 500 行的文件"
   成本: $0.15 (主要是输出令牌)

✅ "显示需要对这个文件进行的更改"
   成本: $0.03 (解释 vs 完整代码)
```

**2. 使用差异而非完整文件:**

```
❌ 生成完整文件: 5,000 输出令牌
✅ 生成差异: 200 输出令牌
节省: 96%
```

**3. 批量操作:**

```
❌ 10 次单独请求: 10 × $0.06 = $0.60
✅ 1 次批量请求: 1 × $0.10 = $0.10
节省: 83%
```

**4. 缓存常用上下文:**

```
加载 CLAUDE.md 100 次:
100 × 5,000 令牌 = 500,000 输入令牌 = $1.50

缓存 CLAUDE.md:
1 × 5,000 令牌 = 5,000 输入令牌 = $0.015
节省: 99%
```

### ROI 计算

**节省的开发时间:**

```
手动代码审查: 2 小时 × $100/小时 = $200
自动化 /review: 2 分钟 + $0.10 = $0.10

ROI: (200 - 0.10) / 0.10 = 1,999x 回报
```

**质量提升:**

```
通过 /review 发现的 bug: 5
在生产环境修复的成本: 5 × $500 = $2,500
/review 的成本: $0.10

ROI: $2,500 / $0.10 = 25,000x 回报
```

---

## 最佳实践总结

### 要做的 ✅

1. **具体明确**: 针对确切的文件和行号
2. **使用增量编辑**: Edit 工具 > 完全重写
3. **批量操作**: 合并相关请求
4. **利用 CLAUDE.md**: 写一次标准,永久引用
5. **使用引用**: "那个函数" vs 重复上下文
6. **先 Grep**: 查找后再读取
7. **监控使用**: 跟踪和分析令牌消耗
8. **启用缓存**: 跨会话重用上下文

### 不要做的 ❌

1. **不要读取整个目录**: 要有选择性
2. **不要重复指令**: 使用 CLAUDE.md
3. **不要生成完整文件**: 使用差异和编辑
4. **不要加载不必要的上下文**: 懒加载
5. **不要忽视令牌成本**: 监控和优化
6. **不要跳过摘要**: 让旧上下文摘要化

### 快速成效

**影响大的简单优化:**

1. **添加 CLAUDE.md** → 重复指令减少 70%
2. **使用 Edit 工具** → vs 完全文件重写减少 95%
3. **启用缓存** → 重复上下文减少 99%
4. **批量请求** → 总令牌减少 50-80%
5. **针对特定文件** → vs 目录读取减少 90%

---

## 示例: 优化前后

### 优化前

```
用户: "我想为 getUserById 函数添加错误处理。
该函数应该处理找不到用户的情况、数据库错误和无效输入。
使用 try-catch 块并返回适当的错误消息。遵循我们的错误处理
编码标准,包括记录错误、抛出自定义错误类型和使用 async/await。"

Claude:
- 读取整个 users.js 文件: 5,000 令牌
- 生成包含更改的整个文件: 5,000 令牌
- 总计: 10,000 令牌
- 成本: $0.105
```

### 优化后

```
用户: "按照 CLAUDE.md 标准为 getUserById (users.js:45) 添加错误处理"

Claude:
- 只读取 getUserById 函数: 200 令牌
- 使用 Edit 工具进行更改: 100 令牌
- 引用 CLAUDE.md (已缓存): 0 令牌
- 总计: 300 令牌
- 成本: $0.003
```

**结果:**

- 令牌减少: 97%
- 成本减少: 97%
- 时间节省: 相同输出质量,更快响应

---

**下一步**: [Git 工作流集成](04-git-workflow.zh.md) →

**上一步**: [安全最佳实践](02-security-best-practices.zh.md) ←
